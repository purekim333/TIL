'''
김싸피는 등산을 좋아해 주말마다 등산을 한다. 하지만 체력이 약한 김싸피는
최대한 완만한 경사도를 가지는 오르막 길을 좋아한다. 전체 경로 길이가 N인
경로에서 김싸피가 제일 좋아하는 오르막 길의 길이를 출력하는 프로그램을
작성하시오.
- 등산 경로의 지형은 정수 배열 형태로 주어진다.
- 오르막 길은 이전 위치 보다 높거나 같은 경우 계속 이어진다고 판단한다.
- 경사도는 오르막길에서 가장 높은 높이 A 와 가장 낮은 높이 B의 차에서
경로 길이 C 를 나눈 값이다.예) 오르막길 경로가 [1, 3, 4, 5] 인 경우, A = 5,
B = 1, C = 4 이므로 ( A – B ) / C = 1, 따라서 경사도는 1이다.
- 만약 경사도가 같은 경우, 오르막 길이가 긴 경로의 길이를 출력한다.
(경사도가 같은 경우에 대해 부동소숫점 수의 오차는 고려하지 않아도 된다.)
- 최소 오르막 길이는 2 이다.
예시) 다음은 N = 10 인 등산경로 예시이다.
- 주어진 예시에서는 총 3개의 오르막 경로가 존재한다.
(1) [1,3,4,5] 경사도 1 (2) [4,6,7,7] 경사도 0.75 (3) [6,9] 경사도 1.5
위 세 개의 경로 중 경사도가 가장 낮은 경로는 경사도 0.75 로 (2)번 경로가
가장 경사도가 완만하다. 따라서 프로그램은 2번 경로의 길이인 4를 출력해야
한다.
| SSAFY 12기 과목평가 |
[Python트랙] 과목평가2 - 알고리즘 기본
1 3 4 5 4 6 7 7 6 9
1 3 4 5 4 6 7 7 6 9
5
입력
첫 줄에 테스트 케이스 개수 T가 주어진다.
각 테스트 케이스의 첫 줄에는 N이 주어진다.
다음 줄에 N개의 자연수 Ai가 띄어쓰기로 구분되어 주어진다.
(5 ≤ N ≤ 20, 1<=Ai<=100)
출력
각 줄에 테스트케이스 번호를 #번호 형태로 출력하고, 한 칸 띄워 김싸피가
가장 좋아하는 경로 길이를 출력한다. 만약 오르막이 없는 경우 0을
출력한다.
'''
'''
[입력 예시]
3
10
1 3 4 5 4 6 7 7 6 9
10
1 4 7 3 4 5 7 11 13 17
6
1 2 7 2 6 1
( a l g o 2 _ s a m p l e _ i n . t x t 참 고 )
'''

import sys; sys.stdin = open('algo2_sample_in.txt')

T = int(input())

for tc in range(1, T+1) :
    N = int(input())
    A = list(map(int, input().split()))  # 입력 데이터

    diff = [0] * N  # 높이 차를 저장하는 list

    # 높이 차이 계산
    for i in range(1, N):  # i: 1 ~ N
        diff[i] = A[i] - A[i-1]

    tmp_ans_arr = list()  # (경사도, 구간길이) Tuple 데이터를 저장하는 변수
    tmp_len = 1  # 구간길이를 저장하는 임시 변수
    tmp_height = 0  # 지나온 구간의 높이를 저장하는 임시 변수

    # 높이 차이가 0 또는 양수인 구간의 합을 구해 경사도와 길이 정보를 저장한다
    for i in range(1, N):  # 높이차 배열을 순회
        difference = diff[i]
        if difference >= 0:  # 높이차가 양수인 경우, 길이 및 높이차 추가
            tmp_len += 1
            tmp_height += difference
        else:  # difference < 0
            if tmp_len > 1 and tmp_height > 0:  # 구간길이가 2 이상, 높이 차이가 0보다 큰 데이터만 저장
                tmp_ans_arr.append((tmp_height / tmp_len, tmp_len))  # (경사도, 구간길이) tuple 저장
            # 임시 변수 초기화
            tmp_len = 1
            tmp_height = 0

    # 반복문 탈출 후, 잔여 데이터 처리
    if tmp_len > 1 and tmp_height > 0:
        tmp_ans_arr.append((tmp_height / tmp_len, tmp_len))

    # 정답 배열에 적어도 1개 이상의 정답 후보가 존재한다면,
    if tmp_ans_arr:
        ans = tmp_ans_arr[0]  # 첫번째 데이터로 초기화
        for tmp_ans in tmp_ans_arr:  # 정답 후보를 순회
            # 경사도가 더 작거나 같으며, 길이가 길거나 같은 데이터가 있다면 정답 갱신
            if tmp_ans[0] <= ans[0] and tmp_ans[1] >= ans[1]:
                ans = tmp_ans
        print(f'#{tc} {ans[1]}')  # tuple 데이터의 1번 인덱스가 가리키는 정보가 구간 길이
    # 정답 배열에 아무런 데이터도 존재하지 않는다면,
    else:
        print(f'#{tc} 0')  # 0 출력